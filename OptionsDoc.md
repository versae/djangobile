## Middleware ##

You can get device attribute in request object through a middleware.

```
MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.middleware.doc.XViewMiddleware',
    # In order to use request.device in views.
    'djangobile.middleware.DjangoMobileMiddleware',
)
```

## Application ##

Djangobile provides override\_media\_url and device\_media\_url in order to make easier to get media path according to device capabilities.

```
INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.admin',
    # In order to use override_media_url and device_media_url templatetag
    # in templates.
    'djangobile',
)
```

## PyWURFL class ##

In order to provide your own WURFL class to djangobile, you must set WURFL\_CLASS variable.

```
# Python WURFL class generated by wurfl2python.py script from pywurfl.
WURFL_CLASS = 'djangobile.wurfl'
```

## User agent search algorithm ##

Djangobile can use three distinct search algorithm: Tokenizer (by default), Jaro Winkler or Levenshtein distance.

```
# Possible values are Tokenizer (default), JaroWinkler and LevenshteinDistance.
# JaroWinkler and LevenshteinDistance require Levenshtein Module >= 0.10.1.
USER_AGENT_SEARCH_ALGORITHM = 'Tokenizer'
```

For JaroWinkler search algorithm JARO\_WINKLER\_ACCURACY can be a value between 0 and 1. With values close to 1 you get a slower search.

```
# Accuracy value for JaroWinkler search algorithm (0 to 1).
# Default: 0.9
JARO_WINKLER_ACCURACY = 0.9
```

## Capabilities search ##

In order to choose a template, djangobile uses a capabilities set to get the right template.

```
# List of device capabilities to order template search.
# Default: (id, user_agent, fall_back, preferred_markup, model_name, brand_name,
#           family)
DEVICE_SEARCH_ORDER = (
    'user_agent',
    'brand_name',
)
```

## Devices definition ##

In order to define new devices, a file extra\_devices.py can be created in the project root. The device definition uses PyWURFL syntax.

```
from djangobile import devices


devices.add(parent='generic',
            devid='fennec',
            devua='Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.1b2pre) Gecko/20081015 Fennec/1.0a1')
```

There are several optional parameters you can find in [PyWURFL Site](http://celljam.net/). You must always specify:
  * parent: It is the parent class the new device extends.
  * devid: A string to name the device.
  * devua: The user agent string of the device.

## Devices families definition ##

One definition of family is a set of capabilities that aims to provide designated fine-grained control over the identification devices. In order to define new families, a file extra\_families.py can be created in the project root. The device definition uses PyWURFL QueryLanguage (setting QUERY\_LANGUAGE\_SUPPORT to True in settings.py) or native Python (over Device object) syntax.

```
from djangobile import families


@families.add
def xhtml_mp_device(device):
    return (device.preferred_markup == 'html_wi_oma_xhtmlmp_1_0' or
            (device.preferred_markup == 'html_wi_w3_xhtmlbasic' and 
             device.html_wi_oma_xhtmlmp_1_0 == True))

# The next syntax requires pyparsing module
families['morethan15columns_device'] = """columns >= 15"""
```

Obviously, the Python syntax is incredibly faster.

## Prefix of loader tags ##

Djangobile provides two loader tags which are automatically added in order to make easier to write templates: those are "extends" and "include" templatetags device aware. This settings allows to define the prefix for them. By default its value is 'device', being the templatetags "device\_extends" and "device\_include". But if it's None , the native templatetags will be overwritten with those where suitable.

```
# Prefix for "extends" and "includes" templatetags device aware.
# If None, the native templatetags will be overwritten with
# those where suitable.
# Default: device.
# And its use in templates is such as {% device_extends "template.hmtl" %}
DEVICE_LOADER_TAGS_PREFIX = 'device'
```

## Prefix of device\_media\_url tag ##

By default its value is 'device', being the templatetag "device\_media\_url".

```
# Prefix for media_url templatetag device aware.
# If None, the templatetags is named media_url
# Default: device. # And its use in templates is such as {% device_media_url "css/style.css" %}
DEVICE_MEDIA_URL_TAG_PREFIX = None
```

## Show device log ##

In order to show detected device information in standard ouput, you can use this setting.

```
# If you set this to True, djangobile will print information about device in
# each request through standard output. Useful to debug issues.
# Default: True
DEVICE_SHOW_LOG = True
```


## Switch device detection ##

`DEVICE_DETECTION_VARIABLE` option can be used to define a parameter to switch between the djangobile and the original rendering modes, this is useful to check different rendering systems from a mobile device.

The default parameter is _device\_detection_ but you can change it adding the `DEVICE_DETECTION_VARIABLE` option to your **settings.py** file.

```
# Setting this parameter to false will disable the device detection, rendering
# the page as a desktop system in your mobile device.
# Default: device_detection
DEVICE_DETECTION_VARIABLE = 'device_detection'
```

Djangobile expects to find that parameter into a GET request so, with the
default configuration, adding `?device_detection=false` will do the trick.

```
http://your.djangobile.powered.site?device_detection=false
```